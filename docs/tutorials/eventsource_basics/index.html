<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs with-toc">
  <head>
    <meta charset="UTF-8" />
    <title>Streaming updates with server-sent events · WebPlatform Docs</title>
    <link rel="stylesheet" href="/assets/css/docs.css" />
    <link rel="stylesheet" href="/assets/css/highlight.css" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    <!--[if lt IE 7]><script src="/bower_components/ie7-js/lib/IE7.js"></script><![endif]-->
    <!--[if lt IE 8]><script src="/bower_components/ie7-js/lib/IE8.js"></script><![endif]-->
    <!--[if lt IE 9]><script src="/bower_components/ie7-js/lib/IE9.js"></script><![endif]-->
    <!--[if lt IE 8]><link rel="stylesheet" href="/assets/css/ie7.css"><![endif]-->
    <meta property="readiness" content="Ready to Use" />
    
    <meta name="description" content="An introduction to server-sent events." />
    <script src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script src="/bower_components/vue/dist/vue.min.js"></script>
  </head>
  <body class="mediawiki ltr sitedir-ltr skin-webplatform action-view">
    <div class="readiness-state Ready_to_Use"><p>This page is <a>Ready to Use</a></p></div>
    <header id="mw-head" class="noprint">
      <div class="container">
        <div id="p-logo">
            <a href="/"  title="Visit the home page"></a>
        </div>
      </div>
    </header>
    <nav id="sitenav">
    <div class="container">
      <ul class="links">
          <li><a href="/" class="active">THE DOCS</a></li>
          <li><a href="/docs/Community">CONNECT</a></li>
          <li><a href="/docs/WPD/Contributors_Guide/">CONTRIBUTE</a></li>
          <li><a href="/blog/">BLOG</a></li>
      </ul>
    </div>
    </nav>

    <div id="siteNotice">
      <div id="localNotice" dir="ltr" lang="en">
    
        <div class="notice" style="margin:10px auto; position: relative; width: 90%; max-width: 950px;">
          <div style="padding: 10px; border-radius: 4px; background-color: rgb(249, 247, 243); box-shadow: 0px 0px 1px rgb(167, 169, 172);">
            <strong>Notice:</strong>&nbsp;The WebPlatform project, supported by various stewards between 2012 and 2015, has been <b>discontinued</b>. This site is now available on <a href="https://github.com/webplatform/webplatform.github.io/">github</a>.
          </div>
        </div>
    
      </div>
    </div>

    <div id="content" class="mw-body">
      <div class="container">
        <a id="top"></a>
        <div class="tool-area">
              <div id="hierarchy-menu">
                  <ol id="breadcrumb-info" class="breadcrumbs">
                    <li><a href="/">DOCS</a></li>
                  	<li><a href="/docs/tutorials/">tutorials</a></li><li><a href="/docs/tutorials/eventsource_basics/">eventsource basics</a></li>
                  </ol>
              </div>
        </div>
        <div id="page">
          <div id="page-content">
            <div id="main-content">

<h1>Streaming updates with server-sent events</h1>
<p><strong>By <a href="http://www.html5rocks.com/profiles/#ericbidelman">Eric Bidelman</a></strong><br>
Originally published Nov. 30, 2010, updated: June 16, 2011</p>
<h2>Summary</h2>
<p>An introduction to server-sent events.</p>
<h2>Introduction</h2>
<p>I wouldn’t be surprised if you’ve stumbled on this article wondering, “What the heck are <a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> (SSEs)?” Many people have never heard of them, and rightfully so. Over the years, the specification has seen significant changes, and the API has taken somewhat of a back seat to newer, sexier communication protocols such as the <a href="http://www.html5rocks.com/tutorials/#websockets">WebSocket API</a>. The idea behind SSEs may be familiar: a web app “subscribes” to a stream of updates generated by a server and, whenever a new event occurs, a notification is sent to the client. But to really understand Server-Sent Events, we need to understand the limitations of its AJAX predecessors, which include:</p>
<p><strong>Polling</strong> is a traditional technique used by the vast majority of AJAX applications. The basic idea is that the application repeatedly polls a server for data. If you’re familiar with the HTTP protocol, you know that fetching data revolves around a request/response format. The client makes a request and waits for the server to respond with data. If none is available, an empty response is returned. So what’s the big deal with polling? Extra polling creates greater HTTP overhead.</p>
<p><strong>Long polling (Hanging GET / COMET)</strong> is a slight variation on polling. In long polling, if the server does not have data available, the server holds the request open until new data is made available. Hence, this technique is often referred to as a &quot;hanging GET&quot;. When information becomes available, the server responds, closes the connection, and the process is repeated. The effect is that the server is constantly responding with new data as it becomes available. The shortcoming is that the implementation of such a procedure typically involves hacks such as appending script tags to an “infinite” iframe. We can do better than hacks!</p>
<p>Server-Sent Events, on the other hand, have been designed from the ground up to be efficient. When communicating using SSEs, a server can push data to your app whenever it wants, without the need to make an initial request. In other words, updates can be streamed from server to client as they happen. SSEs open a single unidirectional channel between server and client.</p>
<p>The main difference between Server-Sent Events and long polling is that SSEs are handled directly by the browser and the user simply has to listen for messages.</p>
<h2>Server-Sent Events vs. WebSockets</h2>
<p>Why would you choose Server-Sent Events over WebSockets? Good question.</p>
<p>One reason SSEs have been kept in the shadow is because later APIs like <a href="http://www.html5rocks.com/tutorials/#websockets">WebSockets</a> provide a richer protocol to perform bi-directional, full-duplex communication. Having a two-way channel is more attractive for things like games, messaging apps, and for cases where you need near real-time updates in both directions. However, in some scenarios <em>data doesn’t need to be sent from the client</em>. You simply need updates from some server action. A few examples would be friends’ status updates, stock tickers, news feeds, or other automated data push mechanisms (e.g., updating a client-side Web SQL Database or IndexedDB object store). If you’ll need to send data to a server, <code>XMLHttpRequest</code> is always a friend.</p>
<p>SSEs are sent over traditional HTTP. That means they <em>do not require a special protocol or server implementation</em> to get working. WebSockets, on the other hand, require full-duplex connections and new Web Socket servers to handle the protocol. In addition, Server-Sent Events have a variety of features that WebSockets lack by design, such as <em>automatic reconnection</em>, <em>event IDs</em>, and the ability to <em>send arbitrary events</em>.</p>
<h2>JavaScript API</h2>
<p>To subscribe to an event stream, create an <code>EventSource</code> object and pass it the URL of your stream:</p>
<pre><code class="js"> <span class="hljs-keyword">if</span> (!!<span class="hljs-built_in">window</span>.EventSource) {
   <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">'stream.php'</span>);
 } <span class="hljs-keyword">else</span> {
   <span class="hljs-comment">// Result to xhr polling :(</span>
 }
</code></pre>
<p><strong>Note:</strong> If the URL passed to the <code>EventSource</code> constructor is an absolute URL, its origin (scheme, domain, port) must match that of the calling page.</p>
<p>Next, set up a handler for the <code>message</code> event. You can optionally listen for <code>open</code> and <code>error</code>:</p>
<pre><code class="js"> source.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-built_in">console</span>.log(e.data);
 }, <span class="hljs-literal">false</span>);

 source.addEventListener(<span class="hljs-string">'open'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-comment">// Connection was opened.</span>
 }, <span class="hljs-literal">false</span>);

 source.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">if</span> (e.readyState == EventSource.CLOSED) {
     <span class="hljs-comment">// Connection was closed.</span>
   }
 }, <span class="hljs-literal">false</span>);
</code></pre>
<p>When updates are pushed from the server, the <code>onmessage</code> handler fires and new data is available in its <code>e.data</code> property. The magical part is that whenever the connection is closed, the browser will automatically reconnect to the source after ~3 seconds. Your server implementation can even have control over this reconnection timeout. See “Controlling the reconnection timeout” in the next section.</p>
<p>That’s it. Your client is now ready to process events from <code>stream.php</code>.</p>
<h2>Event Stream Format</h2>
<p>Sending an event stream from the source is a matter of constructing a plaintext response, served with a <code>text/event-stream</code> Content-Type, that follows the SSE format. In its basic form, the response should contain a &quot;<code>data:</code>&quot; line, followed by your message, followed by two “\n” characters to end the stream:</p>
<pre><code class="yaml"> <span class="hljs-typedef"><span class="hljs-keyword">data</span>: <span class="hljs-type">My</span> message\n\n</span>
</code></pre>
<h3>Multiline Data</h3>
<p>If your message is longer, you can break it up by using multiple &quot;<code>data:</code>&quot; lines. Two or more consecutive lines beginning with &quot;<code>data:</code>&quot; will be treated as a single piece of data, meaning only one <code>message</code> event will be fired. Each line should end in a single “\n” (except for the last, which should end with two). The result passed to your <code>message</code> handler is a single string concatenated by newline characters. For example:</p>
<pre><code class="yaml"> data: first <span class="hljs-keyword">line</span>\<span class="hljs-keyword">n</span>
 data: second <span class="hljs-keyword">line</span>\<span class="hljs-keyword">n</span>\<span class="hljs-keyword">n</span>
</code></pre>
<p>will produce “first line\nsecond line” in <code>e.data</code>. One could then use <code>e.data.split('\n').join()</code> to reconstruct the message sans “\n” characters.</p>
<h3>Send JSON Data</h3>
<p>Using multiple lines makes it easy to send JSON without breaking syntax:</p>
<pre><code class="yaml"> <span class="hljs-attribute">data</span>: <span class="hljs-string">{\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">"msg": "hello world",\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">"id": 12345\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">}\n\n</span>
</code></pre>
<p>and possible client-side code to handle that stream:</p>
<pre><code class="js"> source.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);
   <span class="hljs-built_in">console</span>.log(data.id, data.msg);
 }, <span class="hljs-literal">false</span>);
</code></pre>
<h3>Associating an ID with an Event</h3>
<p>You can send a unique id with a stream event by including a line starting with &quot;<code>id:</code>&quot;:</p>
<pre><code class="yaml"> <span class="hljs-attribute">id</span>: <span class="hljs-string">12345\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">GOOG\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">556\n\n</span>
</code></pre>
<p>Setting an ID lets the browser keep track of the last event fired so that if the connection to the server is dropped, a special HTTP header (<code>Last-Event-ID</code>) is set with the new request. This lets the browser determine which event is appropriate to fire. The <code>message</code> event contains a <code>e.lastEventId</code> property.</p>
<h3>Controlling the reconnection timeout</h3>
<p>The browser attempts to reconnect to the source roughly 3 seconds after each connection is closed. You can change that timeout by including a line beginning with &quot;<code>retry:</code>&quot;, followed by the number of milliseconds to wait before trying to reconnect.</p>
<p>The following example attempts a reconnect after 10 seconds:</p>
<pre><code class="yaml"> <span class="hljs-attribute">retry</span>: <span class="hljs-string">10000\n</span>
 <span class="hljs-attribute">data</span>: <span class="hljs-string">hello world\n\n</span>
</code></pre>
<h3>Specifying an event name</h3>
<p>A single event source can generate different types of events by including an event name. If a line beginning with &quot;<code>event:</code>&quot; is present, followed by a unique name for the event, the event is associated with that name. On the client, an event listener can be setup to listen to that particular event.</p>
<p>For example, the following server output sends three types of events, a generic ‘message’ event, 'userlogon’, and ‘update’ event:</p>
<pre><code class="yaml"> data: {<span class="hljs-string">"msg"</span>: <span class="hljs-string">"First message"</span>}\<span class="hljs-keyword">n</span>\<span class="hljs-keyword">n</span>
 event: userlogon\<span class="hljs-keyword">n</span>
 data: {<span class="hljs-string">"username"</span>: <span class="hljs-string">"John123"</span>}\<span class="hljs-keyword">n</span>\<span class="hljs-keyword">n</span>
 event: <span class="hljs-keyword">update</span>\<span class="hljs-keyword">n</span>
 data: {<span class="hljs-string">"username"</span>: <span class="hljs-string">"John123"</span>, <span class="hljs-string">"emotion"</span>: <span class="hljs-string">"happy"</span>}\<span class="hljs-keyword">n</span>\<span class="hljs-keyword">n</span>
</code></pre>
<p>With event listeners setup on the client:</p>
<pre><code class="js"> source.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);
   <span class="hljs-built_in">console</span>.log(data.msg);
 }, <span class="hljs-literal">false</span>);

 source.addEventListener(<span class="hljs-string">'userlogon'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'User login:'</span> + data.username);
 }, <span class="hljs-literal">false</span>);

 source.addEventListener(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);
   <span class="hljs-built_in">console</span>.log(data.username + <span class="hljs-string">' is now '</span> + data.emotion);
 }, <span class="hljs-literal">false</span>);
</code></pre>
<h2>Server Examples</h2>
<p>A simple server implementation in PHP:</p>
<pre><code> &lt;?php
 header(<span class="hljs-string">'Content-Type: text/event-stream'</span>);
 header(<span class="hljs-string">'Cache-Control: no-cache'</span>); // recommended <span class="hljs-keyword">to</span> prevent caching <span class="hljs-keyword">of</span> event data.
 ?&gt;

 /**
  * Constructs the SSE data format and flushes that data <span class="hljs-keyword">to</span> the client.
  *
  * @param string <span class="hljs-variable">$id</span> Timestamp/id <span class="hljs-keyword">of</span> this connection.
  * @param string <span class="hljs-variable">$msg</span> Line <span class="hljs-keyword">of</span> text that should be transmitted.
  */
 <span class="hljs-keyword">function</span> sendMsg(<span class="hljs-variable">$id</span>, <span class="hljs-variable">$msg</span>) {
   echo <span class="hljs-string">"id: $id"</span> . PHP_EOL;
   echo <span class="hljs-string">"data: $msg"</span> . PHP_EOL;
   echo PHP_EOL;
   ob_flush();
   flush();
 }

 <span class="hljs-variable">$serverTime</span> = time();

 sendMsg(<span class="hljs-variable">$serverTime</span>, <span class="hljs-string">'server time: '</span> . date(<span class="hljs-string">"h:i:s"</span>, time()));
</code></pre>
<p><a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/demo/sse.php">Download the code</a></p>
<p>Here’s a similiar implementation using <a href="http://nodejs.org">Node JS</a>:</p>
<pre><code class="js"> <span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
 <span class="hljs-keyword">var</span> sys = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sys'</span>);
 <span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

 http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
   <span class="hljs-comment">//debugHeaders(req);</span>

   <span class="hljs-keyword">if</span> (req.headers.accept &amp;&amp; req.headers.accept == <span class="hljs-string">'text/event-stream'</span>) {
     <span class="hljs-keyword">if</span> (req.url == <span class="hljs-string">'/events'</span>) {
       sendSSE(req, res);
     } <span class="hljs-keyword">else</span> {
       res.writeHead(<span class="hljs-number">404</span>);
       res.end();
     }
   } <span class="hljs-keyword">else</span> {
     res.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span>});
     res.write(fs.readFileSync(__dirname + <span class="hljs-string">'/sse-node.html'</span>));
     res.end();
   }
 }).listen(<span class="hljs-number">8000</span>);

 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendSSE</span>(<span class="hljs-params">req, res</span>) </span>{
   res.writeHead(<span class="hljs-number">200</span>, {
     <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/event-stream'</span>,
     <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'no-cache'</span>,
     <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'keep-alive'</span>
   });

   <span class="hljs-keyword">var</span> id = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toLocaleTimeString();

   <span class="hljs-comment">// Sends a SSE every 5 seconds on a single connection.</span>
   setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
     constructSSE(res, id, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toLocaleTimeString());
   }, <span class="hljs-number">5000</span>);

   constructSSE(res, id, (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toLocaleTimeString());
 }

 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructSSE</span>(<span class="hljs-params">res, id, data</span>) </span>{
   res.write(<span class="hljs-string">'id: '</span> + id + <span class="hljs-string">'\n'</span>);
   res.write(<span class="hljs-string">"data: "</span> + data + <span class="hljs-string">'\n\n'</span>);
 }

 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debugHeaders</span>(<span class="hljs-params">req</span>) </span>{
   sys.puts(<span class="hljs-string">'URL: '</span> + req.url);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> req.headers) {
     sys.puts(key + <span class="hljs-string">': '</span> + req.headers[key]);
   }
   sys.puts(<span class="hljs-string">'\n\n'</span>);
 }
</code></pre>
<p><a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/demo/node-sse.js">Download the code</a></p>
<h4>sse-node.html:</h4>
<pre><code class="html"> <span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"utf-8"</span> /&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
     <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">'/events'</span>);
     source.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
       <span class="hljs-built_in">document</span>.body.innerHTML += e.data + <span class="hljs-string">'&lt;br&gt;'</span>;
     };
   </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<h2>Cancel an event stream</h2>
<p>Normally, the browser auto-reconnects to the event source when the connection is closed, but that behavior can be canceled by either the client or server.</p>
<p>To cancel a stream from the client, simply call <code>source.close();</code>. To cancel a stream from the server, respond with a non &quot;<code>text/event-stream</code>&quot; Content-Type or return an HTTP status other than <code>200 OK</code> (e.g., <code>404 Not Found</code>).</p>
<p>Both methods will prevent the browser from re-establishing the connection.</p>
<h2>A Word on Security</h2>
<p>From the WHATWG’s section on <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a>:</p>
<blockquote>
<p><em>Authors should check the origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from. Otherwise, bugs in the author’s message handling code could be exploited by hostile sites.</em></p>
</blockquote>
<p>So as an extra level of precaution, be sure to verify that <code>e.origin</code> in your <code>message</code> handler matches your app’s origin:</p>
<pre><code class="js"> source.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
   <span class="hljs-keyword">if</span> (e.origin != <span class="hljs-string">'http://example.com'</span>) {
     alert(<span class="hljs-string">'Origin was not http://example.com'</span>);
     <span class="hljs-keyword">return</span>;
   }
   ...
 }, <span class="hljs-literal">false</span>);
</code></pre>
<p>Another good idea is to check the integrity of the data you receive:</p>
<blockquote>
<p><em>Furthermore, even after checking the origin attribute, authors should also check that the data in question is of the expected format…</em></p>
</blockquote>
<h2>Demo</h2>
<p>A <a href="http://googlecodesamples.com/html5/sse/sse.html">demo app</a> written in PHP is available on googlecodesamples.com along with its <a href="https://github.com/html5rocks/www.html5rocks.com">source</a>.</p>
<h2>References</h2>
<ul>
<li><a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events specification</a></li>
<li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a></li>
</ul>

<h2>Attributions</h2>
<ul>
	<li><p>Portions of this content come from HTML5Rocks! <a href="http://www.html5rocks.com/tutorials/eventsource/basics/">article</a></p>
</li>
</ul>
            </div>
            <div class="topics-nav">
              <ul>
                <li><a href="/docs/Beginners">Beginners</a></li>
                <li><a href="/docs/concepts">Concepts</a></li>
                <li><a href="/docs/html">HTML</a></li>
                <li><a href="/docs/css">CSS</a></li>
                <li><a href="/docs/concepts/accessibility">Accessibility</a></li>
                <li><a href="/docs/javascript">JavaScript</a></li>
                <li><a href="/docs/dom">DOM</a></li>
                <li><a href="/docs/svg">SVG</a></li>
              </ul>
            </div>
            <div class="clear"></div>
          </div>
        </div>
      </div>
    </div>
    <footer id="mw-footer">
      <div class="container">
        <div id="footer-wordmark">
          <a href="https://github.com/webplatform/docs/blob/master/LICENSE.md" class="license">
            <img src="/assets/cc-by-black.svg" width="120" height="42" alt="Content available under CC-BY, except where otherwise noted.">
          </a>
          <a href="/"><span id="footer-title">WebPlatform<span id="footer-title-light">.org</span></span></a>
        </div>
        <!-- ul class="stewards">
          <li class="steward-w3c"><a href="/stewards/w3c">W3C</a></li>
        </ul -->
      </div>
    </footer>
    <script src="/assets/js/docs.js"></script>
  </body>
</html>
